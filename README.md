# microjava-ast-interpreter
A MicroJava compiler that generates an abstract syntax tree (AST), and an interpreter and visualizer for said AST. 
Documentation is available at https://ssw.jku.at/Teaching/Projects/

JavaFX Controls (org.openjfx:javafx-controls:17.0.2): Provides GUI components like buttons, tables, tree views, and lists for the AST visualizer.
JavaFX FXML (org.openjfx:javafx-fxml:17.0.2): Enables loading the GUI layout from FXML files (e.g., ast-view.fxml).
JavaFX Web (org.openjfx:javafx-web:17.0.2): Allows displaying SVG visualizations of the AST in a WebView component.
JavaFX Swing (org.openjfx:javafx-swing:17.0.2): Provides integration between JavaFX and Swing components if needed.
Apache Batik All (org.apache.xmlgraphics:batik-all:1.17): Handles rendering and manipulation of SVG files for AST visualization.
JetBrains Annotations (org.jetbrains:annotations:RELEASE): Supplies annotations for better code documentation and IDE support.
Test Dependencies (test scope):
JUnit Jupiter API (org.junit.jupiter:junit-jupiter-api:5.10.0): Provides the API for writing unit tests.
JUnit Jupiter Engine (org.junit.jupiter:junit-jupiter-engine:5.10.0): Executes JUnit 5 tests.
Build Plugins:
Maven Compiler Plugin (org.apache.maven.plugins:maven-compiler-plugin:3.11.0): Compiles Java source code to bytecode.
JavaFX Maven Plugin (org.openjfx:javafx-maven-plugin:0.0.8): Facilitates running JavaFX applications and managing JavaFX modules.
Additional Tools (Not Maven Dependencies):
Coco/R (Coco.jar in src/main/java/mj/run/): A compiler generator tool used to create the parser and scanner from the attribute grammar file (ASTMicroJava.atg). This is pre-included in the project.
Prerequisites:
Java 17+: Required for JavaFX support.
Maven 3.6+: For dependency resolution, compilation, and running the application.
All these dependencies are downloaded automatically when you run mvn clean install or mvn clean javafx:run. No manual downloads or installations are needed beyond ensuring Java and Maven are set up on your system.

To run it:-.\mvnw.cmd javafx:run

The project is a MicroJava compiler that generates an abstract syntax tree (AST), with an interpreter and visualizer for the AST.
It uses JavaFX for the GUI (ASTViewerApplication and ASTViewerController).
The interpreter executes the AST and manages memory stacks.
The project uses Maven for build and dependency management, with dependencies including JavaFX modules and Apache Batik for SVG handling.

What is MicroJava?
MicroJava is a simplified subset of the Java programming language designed for educational purposes, particularly for teaching compiler construction and programming language concepts. It includes basic features like variables, control structures (if-else, while), methods, arrays, and I/O operations, but omits advanced Java features like classes, inheritance, and exceptions.

Project Description
This project implements a complete MicroJava compiler and interpreter system. It consists of:

A parser that analyzes MicroJava source code and generates an Abstract Syntax Tree (AST).
An interpreter that executes the AST by simulating a virtual machine with memory management.
A visualizer (GUI application) that displays the AST structure, symbol tables, and execution state in real-time.
The project is built using Java and leverages tools like Coco/R for parser generation and JavaFX for the graphical user interface.

How It Works
Parsing Phase:

The Scanner tokenizes the MicroJava source code.
The Parser (generated by Coco/R from ASTMicroJava.atg) builds the AST by applying grammar rules.
The AST represents the program's structure as a tree of nodes (e.g., statements, expressions, declarations).
Interpretation Phase:

The Interpreter class executes the AST by traversing the tree.
It maintains separate memory areas: global data, heap (for dynamic allocation), expression stack, and method stack.
Execution simulates a stack-based virtual machine, handling variable assignments, method calls, control flow, and I/O.
Visualization Phase:

The JavaFX-based GUI displays the AST as a tree view.
It shows symbol tables (global and local variables) with their values.
During execution, it highlights the current line of code and AST node being executed.
Supports debugging with step-by-step execution and breakpoints.
Key Features
AST Generation and Visualization: Parses MicroJava code into an AST and displays it graphically using SVG (via Apache Batik).
Interactive Interpreter: Executes the AST with real-time updates to memory and symbol tables.
Debugging Support: Step-through execution, breakpoints on AST nodes, and inspection of memory states.
Symbol Table Management: Displays global and local variables with their types, addresses, and current values.
File Watching: Automatically reloads the AST visualization when the SVG file is updated.
Memory Inspection: Prints heap, method stack, global data, and expression stack contents.
I/O Operations: Supports printing integers/chars and reading input (simulated).
Control Flow: Handles if-else, while loops, method calls, returns, and breaks.
Error Handling: Runtime checks for null references, index out-of-bounds, and stack overflows.
Project Structure and Main Source Files
The project follows a modular structure under src/main/java/:

fx/ Package (JavaFX GUI):

ASTViewerApplication.java: Main application class that launches the JavaFX window.
ASTViewerController.java: Controller for the GUI, handling user interactions like opening files, compiling, running, debugging, and stepping.
TabItem.java: Model class for symbol table entries.
mj/run/ Package (Core Runtime):

Interpreter.java: Executes the AST, managing memory (data, heap, stacks) and simulating execution.
AbstractSyntaxTree.java: Wraps the AST root and provides methods for compilation and execution.
Parser.java & Scanner.java: Generated by Coco/R from ASTMicroJava.atg for parsing.
Token.java: Represents lexical tokens.
mj/impl/ Package (AST Implementation):

Node.java: Base class for all AST nodes.
Obj.java: Represents symbols (variables, methods) in the symbol table.
Operator.java: Defines operators for expressions.
Struct.java: Represents data types (int, char, arrays).
Expr/ Subpackage: Classes for expressions (e.g., BinExpr, Ident, Call).
Statement/ Subpackage: Classes for statements (e.g., If, While, Assignment).
Exceptions/ Subpackage: Custom exceptions for control flow (e.g., ReturnException, BreakException).
mj/symtab/ Package (Symbol Table):

Scope.java: Manages scopes for variables and methods.
Tab.java: Global symbol table.
module-info.java: Defines the Java module with required dependencies.

Libraries and Dependencies
The project uses Maven for dependency management. Key libraries from pom.xml:

JavaFX (v17.0.2):
javafx-controls: For GUI components (buttons, tables, tree views).
javafx-fxml: For loading the GUI layout from ast-view.fxml.
javafx-web: For displaying SVG visualizations in a WebView.
javafx-swing: For integration with Swing components if needed.
Apache Batik (v1.17): For rendering and manipulating SVG files (used for AST visualization).
JUnit Jupiter (v5.10.0): For unit testing (test scope).
JetBrains Annotations (RELEASE): For code annotations.
All dependencies are automatically downloaded by Maven. No additional manual installations are required beyond Java 17+ and Maven.

How to Run the Project
Prerequisites:

Java 17 or higher (required for JavaFX).
Maven 3.6+ installed.
Ensure JavaFX modules are available (included in Java 11+ or can be added separately).
Setup Steps:

Clone or download the project to your local machine.
Navigate to the project root directory (c:/Users/prana/OneDrive/Desktop/microjava-ast-interpreter-main).
Run mvn clean install to download dependencies and compile the project.
Running the Application:

To run the GUI: mvn clean javafx:run
This launches the ASTViewerApplication with the main class fx.ASTViewerApplication.
The application window will open, allowing you to:
Open a .mj file (e.g., sample.mj).
Compile it to generate the AST.
Run or debug the program.
View the AST tree, symbol tables, and execution highlights.
Alternative Build Commands:

mvn clean compile: Compiles the source code.
mvn test: Runs unit tests (if any are implemented).
mvn package: Packages the application into a JAR (though the main execution is via javafx:run).
Sample Usage:

Open sample.mj (a simple program that declares variables, prints values, and uses if-else).
Click "Compile" to parse and build the AST.
Click "Run" to execute and see output in the console.
Use "Debug" and "Step" to inspect execution step-by-step.
Additional Notes
The project includes a sample MicroJava file (sample.mj) for testing.
Documentation is available at https://ssw.jku.at/Teaching/Projects/ for more details on MicroJava.
The parser is generated using Coco/R (Coco.jar is included), so no manual parser modifications are needed.
The GUI uses FXML for layout (src/main/resources/fx/ast-view.fxml) and includes an icon (jku.png).
